# ──────────────────────────────────────────────────────────────
# SparkNode — Deploy Pipeline (Multi-Cloud, Image-Based)
#
# Step 3 of the deployment pipeline:
#   1. CI builds images and pushes to DockerHub  (ci.yml)
#   2. Terraform provisions infrastructure        (terraform.yml)
#   3. This workflow pulls images onto the VM     ← THIS WORKFLOW
#
# Deploys a specific container version by:
#   - SSH into the VM
#   - Updating APP_VERSION in .env
#   - Running docker compose pull + up
#   - Health checking the result
#
# Required GitHub Secrets (per provider):
#   AWS:   AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
#   Azure: ARM_CLIENT_ID, ARM_CLIENT_SECRET, ARM_SUBSCRIPTION_ID, ARM_TENANT_ID
#   GCP:   GCP_CREDENTIALS_JSON
#
# Shared secrets:
#   DEPLOY_SSH_KEY        (PEM private key for VM SSH)
#   DEPLOY_HOST           (VM public IP — can be read from TF output)
#   DOCKERHUB_USERNAME    (for docker login on VM)
#   DOCKERHUB_TOKEN       (for docker login on VM)
#   POSTGRES_PASSWORD     (production DB password)
#   APP_SECRET_KEY        (JWT signing key)
#   SMTP_PASSWORD         (optional)
# ──────────────────────────────────────────────────────────────

name: Deploy SparkNode

on:
  workflow_dispatch:
    inputs:
      cloud_provider:
        description: 'Cloud provider'
        required: true
        default: 'aws'
        type: choice
        options:
          - aws
          - azure
          - gcp
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      image_tag:
        description: 'Container image tag to deploy (semver e.g. 1.2.3, or latest)'
        required: true
        default: 'latest'
        type: string
  # Allow triggering from CI workflow after successful build
  workflow_call:
    inputs:
      cloud_provider:
        type: string
        default: 'aws'
      environment:
        type: string
        default: 'production'
      image_tag:
        type: string
        required: true

concurrency:
  group: deploy-${{ inputs.cloud_provider || 'aws' }}-${{ inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  CLOUD_PROVIDER: ${{ inputs.cloud_provider || 'aws' }}
  APP_DIR: /opt/sparknode
  COMPOSE_FILE: docker-compose.prod.yml
  IMAGE_TAG: ${{ inputs.image_tag || 'latest' }}
  DOCKERHUB_ORG: ${{ vars.DOCKERHUB_ORG || 'zuber2301' }}

jobs:
  # ────────────────────────────────────────────────────────────
  # Job 1: Deploy (image pull)
  # ────────────────────────────────────────────────────────────
  deploy:
    name: Deploy ${{ inputs.image_tag || 'latest' }} to ${{ inputs.environment || 'production' }} (${{ inputs.cloud_provider || 'aws' }})
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: https://${{ vars.DOMAIN || 'app.sparknode.io' }}

    steps:
      - name: Validate inputs
        run: |
          TAG="${{ env.IMAGE_TAG }}"
          if [ -z "$TAG" ]; then
            echo "::error::image_tag is required"
            exit 1
          fi
          echo "Deploying image tag: $TAG"
          echo "Provider: ${{ env.CLOUD_PROVIDER }}"
          echo "Environment: ${{ inputs.environment || 'production' }}"

      - name: Determine SSH user for cloud provider
        id: ssh_config
        run: |
          PROVIDER="${{ env.CLOUD_PROVIDER }}"
          case "$PROVIDER" in
            aws)   SSH_USER="ubuntu" ;;
            azure) SSH_USER="${{ vars.AZURE_SSH_USER || 'azureuser' }}" ;;
            gcp)   SSH_USER="${{ vars.GCP_SSH_USER || 'ubuntu' }}" ;;
            *)     SSH_USER="ubuntu" ;;
          esac
          echo "ssh_user=$SSH_USER" >> $GITHUB_OUTPUT
          echo "Using SSH user: $SSH_USER for provider: $PROVIDER"

      - name: Determine deploy host
        id: target
        run: |
          PROVIDER="${{ env.CLOUD_PROVIDER }}"
          ENV="${{ inputs.environment }}"

          # Provider-specific host secrets: DEPLOY_HOST_AWS, DEPLOY_HOST_AZURE, DEPLOY_HOST_GCP
          # Falls back to generic DEPLOY_HOST
          case "$PROVIDER" in
            aws)
              HOST="${{ secrets.DEPLOY_HOST_AWS || secrets.DEPLOY_HOST }}"
              ;;
            azure)
              HOST="${{ secrets.DEPLOY_HOST_AZURE || secrets.DEPLOY_HOST }}"
              ;;
            gcp)
              HOST="${{ secrets.DEPLOY_HOST_GCP || secrets.DEPLOY_HOST }}"
              ;;
          esac

          if [ "$ENV" = "staging" ]; then
            HOST="${{ secrets.STAGING_HOST || '' }}"
            [ -z "$HOST" ] && HOST="${{ secrets.DEPLOY_HOST }}"
          fi

          echo "host=$HOST" >> $GITHUB_OUTPUT
          echo "Deploying to $PROVIDER host: $HOST"

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.target.outputs.host }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Pre-deploy database backup
        env:
          HOST: ${{ steps.target.outputs.host }}
          SSH_USER: ${{ steps.ssh_config.outputs.ssh_user }}
        run: |
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@$HOST"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          echo ">>> Backing up database (pre-deploy)..."
          $SSH "mkdir -p $APP_DIR/backups && \
            docker exec sparknode-db pg_dump -U sparknode sparknode 2>/dev/null | \
            gzip > $APP_DIR/backups/pre-deploy-$TIMESTAMP.sql.gz" || echo "WARN: DB backup skipped (container not running?)"

          # Save the current APP_VERSION for rollback reference
          $SSH "grep '^APP_VERSION=' $APP_DIR/.env 2>/dev/null | cut -d= -f2 > $APP_DIR/backups/.previous_version" || true

      - name: Login to DockerHub on VM
        env:
          HOST: ${{ steps.target.outputs.host }}
          SSH_USER: ${{ steps.ssh_config.outputs.ssh_user }}
        run: |
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@$HOST"
          echo ">>> Logging into DockerHub on VM..."
          $SSH "echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME }}' --password-stdin"

      - name: Deploy — pull images & restart
        env:
          HOST: ${{ steps.target.outputs.host }}
          SSH_USER: ${{ steps.ssh_config.outputs.ssh_user }}
          DOMAIN: ${{ vars.DOMAIN || 'app.sparknode.io' }}
        run: |
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@$HOST"
          TAG="${{ env.IMAGE_TAG }}"
          ORG="${{ env.DOCKERHUB_ORG }}"

          echo ">>> Updating APP_VERSION to $TAG in .env..."
          $SSH "cd $APP_DIR && \
            sed -i 's/^APP_VERSION=.*/APP_VERSION=$TAG/' .env && \
            sed -i 's/^DOCKERHUB_ORG=.*/DOCKERHUB_ORG=$ORG/' .env || \
            echo 'DOCKERHUB_ORG=$ORG' >> .env"

          echo ">>> Pulling images: $ORG/sparknode-backend:$TAG, $ORG/sparknode-frontend:$TAG..."
          $SSH "cd $APP_DIR && \
            docker compose -f $COMPOSE_FILE --env-file .env pull backend celery frontend"

          echo ">>> Starting services with new images..."
          $SSH "cd $APP_DIR && \
            docker compose -f $COMPOSE_FILE --env-file .env up -d --remove-orphans"

          echo ">>> Deployed image tag: $TAG"

      - name: Wait for healthy
        env:
          HOST: ${{ steps.target.outputs.host }}
          SSH_USER: ${{ steps.ssh_config.outputs.ssh_user }}
        run: |
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@$HOST"
          echo ">>> Waiting for backend health..."
          sleep 15

          for i in $(seq 1 12); do
            HEALTH=$($SSH "curl -sf http://localhost:8000/health 2>/dev/null || echo unhealthy")
            if [ "$HEALTH" != "unhealthy" ]; then
              echo "✓ Backend is healthy!"
              exit 0
            fi
            echo "  ... attempt $i/12 — waiting 10s"
            sleep 10
          done

          echo "✗ Backend did not become healthy — consider rolling back"
          exit 1

      - name: Post-deploy health check
        env:
          DOMAIN: ${{ vars.DOMAIN || 'app.sparknode.io' }}
        run: |
          sleep 5
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "https://$DOMAIN" 2>/dev/null || echo "000")
          echo "Frontend HTTP status: $HTTP_CODE"

          API_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "https://$DOMAIN/health" 2>/dev/null || echo "000")
          echo "Backend /health status: $API_CODE"

          if [ "$HTTP_CODE" != "200" ] || [ "$API_CODE" != "200" ]; then
            echo "⚠ Some health checks did not pass — check logs"
          fi

      - name: Cleanup
        if: always()
        env:
          HOST: ${{ steps.target.outputs.host }}
          SSH_USER: ${{ steps.ssh_config.outputs.ssh_user }}
        run: |
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@$HOST"
          $SSH "docker image prune -f --filter 'until=168h'" 2>/dev/null || true
          rm -f ~/.ssh/deploy_key

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Provider | ${{ env.CLOUD_PROVIDER }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | \`${{ env.DOCKERHUB_ORG }}/sparknode-backend:${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | \`${{ env.DOCKERHUB_ORG }}/sparknode-frontend:${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY

  # ────────────────────────────────────────────────────────────
  # Job 2: Notify (optional)
  # ────────────────────────────────────────────────────────────
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Deployment result
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "✓ Deployment succeeded — image: ${{ env.IMAGE_TAG }}"
            # Add Slack/Discord/email notification here
          else
            echo "✗ Deployment failed — image: ${{ env.IMAGE_TAG }}"
            # Add failure notification here
          fi
