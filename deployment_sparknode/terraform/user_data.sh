#!/usr/bin/env bash
# ──────────────────────────────────────────────────────────────
# SparkNode — VM cloud-init bootstrap script (Image-Based)
# Runs once on first boot. Installs Docker, configures
# Docker Compose with pre-built images from DockerHub,
# writes env files, starts services with Traefik.
#
# This script does NOT clone the repo or build from source.
# It pulls pre-built container images from DockerHub.
# ──────────────────────────────────────────────────────────────
set -euo pipefail
exec > >(tee /var/log/sparknode-init.log) 2>&1

echo ">>> SparkNode cloud-init starting — $(date -u)"

# ─── Templated variables from Terraform ──────────────────────
PROJECT_NAME="${project_name}"
DOMAIN="${domain}"
ACME_EMAIL="${acme_email}"
POSTGRES_PASSWORD="${postgres_password}"
APP_SECRET_KEY="${app_secret_key}"
SMTP_HOST="${smtp_host}"
SMTP_PORT="${smtp_port}"
SMTP_USER="${smtp_user}"
SMTP_PASSWORD="${smtp_password}"
APP_VERSION="${app_version}"
DOCKERHUB_ORG="${dockerhub_org}"
DOCKERHUB_USERNAME="${dockerhub_username}"
DOCKERHUB_TOKEN="${dockerhub_token}"
ENVIRONMENT="${environment}"

APP_DIR="/opt/$PROJECT_NAME"

# ─── 1. System packages ─────────────────────────────────────
apt-get update -y
apt-get upgrade -y
apt-get install -y \
  ca-certificates curl gnupg lsb-release \
  apt-transport-https software-properties-common \
  git jq unzip fail2ban ufw htop

# ─── 2. Install Docker Engine ────────────────────────────────
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
  gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg

echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

apt-get update -y
apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

systemctl enable docker
systemctl start docker
usermod -aG docker ubuntu

# ─── 3. Firewall ─────────────────────────────────────────────
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw --force enable

# ─── 4. Create application directory ─────────────────────────
mkdir -p "$APP_DIR"

# Create deployment / traefik directories
mkdir -p "$APP_DIR/traefik/acme"
mkdir -p "$APP_DIR/traefik/dynamic"
mkdir -p "$APP_DIR/backups"

# ─── 5. Write production .env ────────────────────────────────
cat > "$APP_DIR/.env" <<ENVEOF
# SparkNode Production Environment — Auto-generated by Terraform
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
PROJECT_NAME=$PROJECT_NAME
ENVIRONMENT=$ENVIRONMENT
DOMAIN=$DOMAIN
ACME_EMAIL=$ACME_EMAIL
APP_VERSION=$APP_VERSION
DOCKERHUB_ORG=$DOCKERHUB_ORG

# PostgreSQL
POSTGRES_USER=sparknode
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
POSTGRES_DB=sparknode

# Backend
DATABASE_URL=postgresql://sparknode:$POSTGRES_PASSWORD@postgres:5432/sparknode
APP_DATABASE_URL=postgresql://sparknode:$POSTGRES_PASSWORD@postgres:5432/sparknode
SECRET_KEY=$APP_SECRET_KEY
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60
CORS_ORIGINS=https://$DOMAIN

# SMTP
SMTP_HOST=$SMTP_HOST
SMTP_PORT=$SMTP_PORT
SMTP_USER=$SMTP_USER
SMTP_PASSWORD=$SMTP_PASSWORD
SMTP_FROM=no-reply@$DOMAIN
SMTP_USE_TLS=true

# Celery
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0
ENVEOF

chmod 600 "$APP_DIR/.env"

# ─── 6. Write Traefik static config ─────────────────────────
cat > "$APP_DIR/traefik/traefik.yml" <<'TRAEFIKEOF'
api:
  dashboard: true
  insecure: false

entryPoints:
  web:
    address: ":80"
    http:
      redirections:
        entryPoint:
          to: websecure
          scheme: https
          permanent: true
  websecure:
    address: ":443"

certificatesResolvers:
  letsencrypt:
    acme:
      email: "$${ACME_EMAIL}"
      storage: /acme/acme.json
      httpChallenge:
        entryPoint: web

providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false
    network: sparknode-network
  file:
    directory: /etc/traefik/dynamic
    watch: true

log:
  level: INFO

accessLog:
  filePath: /var/log/traefik/access.log
  bufferingSize: 100
TRAEFIKEOF

# Patch the ACME email into traefik.yml
sed -i "s|\$${ACME_EMAIL}|$ACME_EMAIL|g" "$APP_DIR/traefik/traefik.yml"

# ─── 7. Write Traefik dynamic middleware config ──────────────
cat > "$APP_DIR/traefik/dynamic/middlewares.yml" <<'MIDEOF'
http:
  middlewares:
    security-headers:
      headers:
        browserXssFilter: true
        contentTypeNosniff: true
        frameDeny: true
        stsIncludeSubdomains: true
        stsPreload: true
        stsSeconds: 31536000
        customFrameOptionsValue: "SAMEORIGIN"
        referrerPolicy: "strict-origin-when-cross-origin"
        customResponseHeaders:
          X-Powered-By: ""
          Server: ""

    rate-limit:
      rateLimit:
        average: 100
        burst: 200
        period: "1m"

    compress:
      compress:
        excludedContentTypes:
          - "text/event-stream"
MIDEOF

# ─── 8. Write production docker-compose ──────────────────────
# Generate docker-compose.prod.yml inline (no repo clone needed)
cat > "$APP_DIR/docker-compose.prod.yml" <<'COMPOSEEOF'
services:
  traefik:
    image: traefik:v3.1
    container_name: $${PROJECT_NAME:-sparknode}-traefik
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik/traefik.yml:/etc/traefik/traefik.yml:ro
      - ./traefik/dynamic:/etc/traefik/dynamic:ro
      - ./traefik/acme:/acme
      - traefik_logs:/var/log/traefik
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(`traefik.$${DOMAIN}`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))"
      - "traefik.http.routers.dashboard.service=api@internal"
      - "traefik.http.routers.dashboard.entrypoints=websecure"
      - "traefik.http.routers.dashboard.tls.certresolver=letsencrypt"
      - "traefik.http.routers.dashboard.middlewares=security-headers@file"
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "traefik", "healthcheck"]
      interval: 10s
      timeout: 5s
      retries: 3

  postgres:
    image: postgres:15.8-alpine
    container_name: $${PROJECT_NAME:-sparknode}-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: $${POSTGRES_USER:-sparknode}
      POSTGRES_PASSWORD: $${POSTGRES_PASSWORD}
      POSTGRES_DB: $${POSTGRES_DB:-sparknode}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-sparknode}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 256M

  redis:
    image: redis:7-alpine
    container_name: $${PROJECT_NAME:-sparknode}-redis
    restart: unless-stopped
    command: redis-server --maxmemory 128mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 256M

  backend:
    image: $${DOCKERHUB_ORG:-zuber2301}/sparknode-backend:$${APP_VERSION:-latest}
    container_name: $${PROJECT_NAME:-sparknode}-backend
    restart: unless-stopped
    environment:
      APP_DATABASE_URL: $${APP_DATABASE_URL:-postgresql://sparknode:$${POSTGRES_PASSWORD}@postgres:5432/sparknode}
      DATABASE_URL: $${DATABASE_URL:-postgresql://sparknode:$${POSTGRES_PASSWORD}@postgres:5432/sparknode}
      SECRET_KEY: $${SECRET_KEY}
      ALGORITHM: $${ALGORITHM:-HS256}
      ACCESS_TOKEN_EXPIRE_MINUTES: $${ACCESS_TOKEN_EXPIRE_MINUTES:-60}
      CORS_ORIGINS: $${CORS_ORIGINS:-https://$${DOMAIN}}
      SMTP_HOST: $${SMTP_HOST:-}
      SMTP_PORT: $${SMTP_PORT:-587}
      SMTP_USER: $${SMTP_USER:-}
      SMTP_PASSWORD: $${SMTP_PASSWORD:-}
      SMTP_FROM: $${SMTP_FROM:-no-reply@$${DOMAIN}}
      SMTP_USE_TLS: $${SMTP_USE_TLS:-true}
      CELERY_BROKER_URL: $${CELERY_BROKER_URL:-redis://redis:6379/0}
      CELERY_RESULT_BACKEND: $${CELERY_RESULT_BACKEND:-redis://redis:6379/0}
      ENVIRONMENT: $${ENVIRONMENT:-production}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.backend.rule=Host(`$${DOMAIN}`) && PathPrefix(`/api`)"
      - "traefik.http.routers.backend.entrypoints=websecure"
      - "traefik.http.routers.backend.tls.certresolver=letsencrypt"
      - "traefik.http.routers.backend.middlewares=security-headers@file,rate-limit@file,compress@file"
      - "traefik.http.services.backend.loadbalancer.server.port=8000"
      - "traefik.http.routers.backend-health.rule=Host(`$${DOMAIN}`) && Path(`/health`)"
      - "traefik.http.routers.backend-health.entrypoints=websecure"
      - "traefik.http.routers.backend-health.tls.certresolver=letsencrypt"
      - "traefik.http.services.backend-health.loadbalancer.server.port=8000"
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8000/health || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 256M

  celery:
    image: $${DOCKERHUB_ORG:-zuber2301}/sparknode-backend:$${APP_VERSION:-latest}
    container_name: $${PROJECT_NAME:-sparknode}-celery
    restart: unless-stopped
    environment:
      DATABASE_URL: $${DATABASE_URL:-postgresql://sparknode:$${POSTGRES_PASSWORD}@postgres:5432/sparknode}
      SECRET_KEY: $${SECRET_KEY}
      ALGORITHM: $${ALGORITHM:-HS256}
      CORS_ORIGINS: $${CORS_ORIGINS:-https://$${DOMAIN}}
      SMTP_HOST: $${SMTP_HOST:-}
      SMTP_PORT: $${SMTP_PORT:-587}
      SMTP_USER: $${SMTP_USER:-}
      SMTP_PASSWORD: $${SMTP_PASSWORD:-}
      SMTP_FROM: $${SMTP_FROM:-no-reply@$${DOMAIN}}
      SMTP_USE_TLS: $${SMTP_USE_TLS:-true}
      CELERY_BROKER_URL: $${CELERY_BROKER_URL:-redis://redis:6379/0}
      CELERY_RESULT_BACKEND: $${CELERY_RESULT_BACKEND:-redis://redis:6379/0}
      ENVIRONMENT: $${ENVIRONMENT:-production}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: celery -A core.celery_app.celery_app worker --loglevel=info --concurrency=4
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 512M

  frontend:
    image: $${DOCKERHUB_ORG:-zuber2301}/sparknode-frontend:$${APP_VERSION:-latest}
    container_name: $${PROJECT_NAME:-sparknode}-frontend
    restart: unless-stopped
    depends_on:
      - backend
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend.rule=Host(`$${DOMAIN}`)"
      - "traefik.http.routers.frontend.entrypoints=websecure"
      - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
      - "traefik.http.routers.frontend.middlewares=security-headers@file,compress@file"
      - "traefik.http.routers.frontend.priority=1"
      - "traefik.http.services.frontend.loadbalancer.server.port=80"
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1/ || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    name: $${PROJECT_NAME:-sparknode}_postgres_data
  redis_data:
    name: $${PROJECT_NAME:-sparknode}_redis_data
  traefik_logs:
    name: $${PROJECT_NAME:-sparknode}_traefik_logs

networks:
  app-network:
    name: $${PROJECT_NAME:-sparknode}-network
    driver: bridge
COMPOSEEOF

# --- Create Monitoring Config ---
mkdir -p "$APP_DIR/monitoring/prometheus"
cat > "$APP_DIR/monitoring/prometheus/prometheus.yml" <<'PROMETHEUSEOF'
global:
  scrape_interval: 15s
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
  - job_name: 'postgres_exporter'
    static_configs:
      - targets: ['postgres_exporter:9187']
  - job_name: 'sparknode-backend'
    metrics_path: '/metrics'
    static_configs:
      - targets: ['backend:8000']
  - job_name: 'node_exporter'
    static_configs:
      - targets: ['node_exporter:9100']
PROMETHEUSEOF

# --- Create Docker Monitoring — Inline for Terraform Provisioning ---
cat > "$APP_DIR/docker-monitoring.yml" <<'MONITORINGEOF'
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:v2.54.0
    container_name: $${PROJECT_NAME:-sparknode}-prometheus
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    logging:
      driver: "awslogs"
      options:
        awslogs-region: $${AWS_REGION:-us-east-1}
        awslogs-group: "/sparknode/prometheus"
        awslogs-stream: "prometheus"
    networks:
      - monitoring-network
      - app-network

  grafana:
    image: grafana/grafana:11.1.0
    container_name: $${PROJECT_NAME:-sparknode}-grafana
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_USER=$${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=$${GRAFANA_ADMIN_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.$${DOMAIN}`)"
      - "traefik.http.routers.grafana.entrypoints=websecure"
      - "traefik.http.routers.grafana.tls.certresolver=letsencrypt"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"
    logging:
      driver: "awslogs"
      options:
        awslogs-region: $${AWS_REGION:-us-east-1}
        awslogs-group: "/sparknode/grafana"
        awslogs-stream: "grafana"
    networks:
      - monitoring-network
      - app-network

  postgres_exporter:
    image: prometheuscommunity/postgres-exporter:v0.15.0
    container_name: $${PROJECT_NAME:-sparknode}-postgres-exporter
    restart: unless-stopped
    environment:
      - DATA_SOURCE_NAME=postgresql://$${POSTGRES_USER}:$${POSTGRES_PASSWORD}@postgres:5432/$${POSTGRES_DB}?sslmode=disable
    networks:
      - monitoring-network
      - app-network

  node_exporter:
    image: prom/node-exporter:v1.8.1
    container_name: $${PROJECT_NAME:-sparknode}-node-exporter
    restart: unless-stopped
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    networks:
      - monitoring-network

volumes:
  prometheus_data:
  grafana_data:

networks:
  monitoring-network:
    driver: bridge
  app-network:
    external: true
    name: $${PROJECT_NAME:-sparknode}-network
MONITORINGEOF

# ─── 9. Login to DockerHub & pull images ─────────────────────
if [ -n "$DOCKERHUB_USERNAME" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
  echo ">>> Logging into DockerHub..."
  echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
fi

# ─── 10. Pull and start services ────────────────────────────
cd "$APP_DIR"
echo ">>> Pulling container images..."
docker compose -f docker-compose.prod.yml -f docker-monitoring.yml --env-file .env pull

echo ">>> Starting services..."
docker compose -f docker-compose.prod.yml -f docker-monitoring.yml --env-file .env up -d

# ─── 11. Set up daily database backup cron ───────────────────
cat > /etc/cron.d/sparknode-backup <<CRONEOF
# Daily PostgreSQL backup at 02:00 UTC
0 2 * * * root docker exec $${PROJECT_NAME}-db pg_dump -U sparknode sparknode | gzip > $APP_DIR/backups/sparknode-\$(date +\%Y\%m\%d-\%H\%M\%S).sql.gz && find $APP_DIR/backups -name "*.sql.gz" -mtime +7 -delete
CRONEOF
chmod 644 /etc/cron.d/sparknode-backup

# ─── 12. Log rotation for Traefik ───────────────────────────
cat > /etc/logrotate.d/traefik <<LOGEOF
/opt/$PROJECT_NAME/traefik/logs/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0644 root root
    postrotate
        docker kill --signal=USR1 $${PROJECT_NAME}-traefik 2>/dev/null || true
    endscript
}
LOGEOF

echo ">>> SparkNode cloud-init complete — $(date -u)"
echo ">>> Application should be available at https://$DOMAIN"
